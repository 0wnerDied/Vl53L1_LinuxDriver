<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>VL53L1linuxdriver: IOCTL interface commands</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">VL53L1linuxdriver
   &#160;<span id="projectnumber">14.1.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__vl53l1__ioctl.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Modules</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">IOCTL interface commands</div>  </div>
</div><!--header-->
<div class="contents">

<p>Ioctl commands for vl53L1.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstmvl53l1__parameter.html">stmvl53l1_parameter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstmvl53l1__roi__t.html">stmvl53l1_roi_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstmvl53l1__roi__t_1_1roi__cfg__t.html">stmvl53l1_roi_t::roi_cfg_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstmvl53l1__roi__full__t.html">stmvl53l1_roi_full_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstmvl53l1__ioctl__calibration__data__t.html">stmvl53l1_ioctl_calibration_data_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstmvl53l1__ioctl__zone__calibration__data__t.html">stmvl53l1_ioctl_zone_calibration_data_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstmvl53l1__ioctl__perform__calibration__t.html">stmvl53l1_ioctl_perform_calibration_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstmvl53l1__autonomous__config__t.html">stmvl53l1_autonomous_config_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga372d0423af5f910d7a572f2ffafb75fb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vl53l1__ioctl.html#ga372d0423af5f910d7a572f2ffafb75fb">VL53L1_MISC_DEV_NAME</a>&#160;&#160;&#160;&quot;stmvl53l1_ranging&quot;</td></tr>
<tr class="separator:ga372d0423af5f910d7a572f2ffafb75fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae98e7032fc7af8d464e6f4ac8f6189ac"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vl53l1__ioctl.html#gae98e7032fc7af8d464e6f4ac8f6189ac">stmvl531_range_data_t</a>&#160;&#160;&#160;VL53L1_RangingMeasurementData_t</td></tr>
<tr class="separator:gae98e7032fc7af8d464e6f4ac8f6189ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga818e91493e897483de8fad8df755e7e6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vl53l1__ioctl.html#ga818e91493e897483de8fad8df755e7e6">stmvl531_zone_calibration_data_t</a>&#160;&#160;&#160;struct _stmvl531_zone_calibration_data_t</td></tr>
<tr class="separator:ga818e91493e897483de8fad8df755e7e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa00d446b725ac0ddc98ad9269da67120"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vl53l1__ioctl.html#gaa00d446b725ac0ddc98ad9269da67120">VL53L1_CALIBRATION_REF_SPAD</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:gaa00d446b725ac0ddc98ad9269da67120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fbcf2a7fb20d015d87b662dd74ae39a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vl53l1__ioctl.html#ga3fbcf2a7fb20d015d87b662dd74ae39a">VL53L1_CALIBRATION_CROSSTALK</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ga3fbcf2a7fb20d015d87b662dd74ae39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga485f406fdc445a984cd120f532848647"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vl53l1__ioctl.html#ga485f406fdc445a984cd120f532848647">VL53L1_CALIBRATION_OFFSET</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ga485f406fdc445a984cd120f532848647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada26d146703c06fff5529587d57cb64b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vl53l1__ioctl.html#gada26d146703c06fff5529587d57cb64b">VL53L1_CALIBRATION_OFFSET_PER_ZONE</a>&#160;&#160;&#160;3</td></tr>
<tr class="separator:gada26d146703c06fff5529587d57cb64b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac54e32ebe0f01d4199f0954ffd5a4045"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vl53l1__ioctl.html#gac54e32ebe0f01d4199f0954ffd5a4045">VL53L1_CALIBRATION_OFFSET_SIMPLE</a>&#160;&#160;&#160;4</td></tr>
<tr class="separator:gac54e32ebe0f01d4199f0954ffd5a4045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga666b84222ce7345773d061a9fafab516"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vl53l1__ioctl.html#ga666b84222ce7345773d061a9fafab516">VL53L1_CALIBRATION_OFFSET_PER_VCSEL</a>&#160;&#160;&#160;5</td></tr>
<tr class="separator:ga666b84222ce7345773d061a9fafab516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac13e726d19839b60a7471d41b1ff9f9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vl53l1__ioctl.html#gaac13e726d19839b60a7471d41b1ff9f9">VL53L1_CALIBRATION_OFFSET_ZERO_DISTANCE</a>&#160;&#160;&#160;6</td></tr>
<tr class="separator:gaac13e726d19839b60a7471d41b1ff9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3e1756ac2d06f0c3ce0180f915bb19b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vl53l1__ioctl.html#gaf3e1756ac2d06f0c3ce0180f915bb19b">VL53L1_IOCTL_START</a>&#160;&#160;&#160;_IO('p', 0x01)</td></tr>
<tr class="separator:gaf3e1756ac2d06f0c3ce0180f915bb19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d8325482353615bad58ec14a7e61a10"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vl53l1__ioctl.html#ga5d8325482353615bad58ec14a7e61a10">VL53L1_IOCTL_STOP</a>&#160;&#160;&#160;_IO('p', 0x05)</td></tr>
<tr class="separator:ga5d8325482353615bad58ec14a7e61a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae15aeca0d52d393e5e0af3d94dfba94f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vl53l1__ioctl.html#gae15aeca0d52d393e5e0af3d94dfba94f">VL53L1_IOCTL_GETDATAS</a>&#160;&#160;&#160;_IOWR('p', 0x0b, stmvl531_range_data_t)</td></tr>
<tr class="separator:gae15aeca0d52d393e5e0af3d94dfba94f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga866f473341d9fb2c8cba7f430785df1b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vl53l1__ioctl.html#ga866f473341d9fb2c8cba7f430785df1b">VL53L1_IOCTL_PARAMETER</a>&#160;&#160;&#160;_IOWR('p', 0x0d, struct stmvl53l1_parameter)</td></tr>
<tr class="separator:ga866f473341d9fb2c8cba7f430785df1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc0270fe045a46443c981bcca1bf6c6c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vl53l1__ioctl.html#gabc0270fe045a46443c981bcca1bf6c6c">VL53L1_IOCTL_ROI</a>&#160;&#160;&#160;_IOWR('p', 0x0e, struct stmvl53l1_roi_t)</td></tr>
<tr class="separator:gabc0270fe045a46443c981bcca1bf6c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98f10e3ab7049b6bb1afe72971e37397"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vl53l1__ioctl.html#ga98f10e3ab7049b6bb1afe72971e37397">VL53L1_IOCTL_MZ_DATA</a>&#160;&#160;&#160;_IOR('p', 0x0f, VL53L1_MultiRangingData_t)</td></tr>
<tr class="separator:ga98f10e3ab7049b6bb1afe72971e37397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7e64b1d59227b4b82bb8db88b268b4a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vl53l1__ioctl.html#gaf7e64b1d59227b4b82bb8db88b268b4a">VL53L1_IOCTL_GETDATAS_BLOCKING</a>&#160;&#160;&#160;_IOWR('p', 0x10, stmvl531_range_data_t)</td></tr>
<tr class="separator:gaf7e64b1d59227b4b82bb8db88b268b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae725507467c87b3446418d237565e05"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vl53l1__ioctl.html#gaae725507467c87b3446418d237565e05">VL53L1_IOCTL_MZ_DATA_BLOCKING</a>&#160;&#160;&#160;_IOR('p', 0x11, VL53L1_MultiRangingData_t)</td></tr>
<tr class="separator:gaae725507467c87b3446418d237565e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4905645a13244636db57baa5b46e479e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vl53l1__ioctl.html#ga4905645a13244636db57baa5b46e479e">VL53L1_IOCTL_CALIBRATION_DATA</a>&#160;&#160;&#160;_IOWR('p', 0x12, struct stmvl53l1_ioctl_calibration_data_t)</td></tr>
<tr class="separator:ga4905645a13244636db57baa5b46e479e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8ccce5670a42edff7b3a66c6202d41a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vl53l1__ioctl.html#gab8ccce5670a42edff7b3a66c6202d41a">VL53L1_IOCTL_ZONE_CALIBRATION_DATA</a>&#160;&#160;&#160;_IOWR('p', 0x12, struct stmvl53l1_ioctl_zone_calibration_data_t)</td></tr>
<tr class="separator:gab8ccce5670a42edff7b3a66c6202d41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57c964dd266d38f1525b43c92638586a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vl53l1__ioctl.html#ga57c964dd266d38f1525b43c92638586a">VL53L1_IOCTL_PERFORM_CALIBRATION</a>&#160;&#160;&#160;_IOW('p', 0x13, struct stmvl53l1_ioctl_perform_calibration_t)</td></tr>
<tr class="separator:ga57c964dd266d38f1525b43c92638586a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaf95795c4e59b6e197c452a541a6613"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vl53l1__ioctl.html#gaeaf95795c4e59b6e197c452a541a6613">VL53L1_IOCTL_AUTONOMOUS_CONFIG</a>&#160;&#160;&#160;_IOWR('p', 0x14, struct stmvl53l1_autonomous_config_t)</td></tr>
<tr class="separator:gaeaf95795c4e59b6e197c452a541a6613"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga7eb4f9f10a8ea88d2af62881c8060860"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vl53l1__ioctl.html#ga7eb4f9f10a8ea88d2af62881c8060860">__stmv53l1_parameter_name_e</a> { <br />
&#160;&#160;<a class="el" href="group__vl53l1__ioctl.html#gga7eb4f9f10a8ea88d2af62881c8060860ac23cbef3e4624ab74dc78ec04af29557">VL53L1_XTALKENABLE_PAR</a> = 2, 
<a class="el" href="group__vl53l1__ioctl.html#gga7eb4f9f10a8ea88d2af62881c8060860a712e39b760cbc9afaed8ec42d6cdc7c3">VL53L1_DEVICEMODE_PAR</a> = 6, 
<a class="el" href="group__vl53l1__ioctl.html#gga7eb4f9f10a8ea88d2af62881c8060860abc081c715c21fa932c4709b497881515">VL53L1_POLLDELAY_PAR</a> = 10, 
<a class="el" href="group__vl53l1__ioctl.html#gga7eb4f9f10a8ea88d2af62881c8060860a774e15d669bfb0ab611b1d74dacf69c4">VL53L1_TIMINGBUDGET_PAR</a> = 11, 
<br />
&#160;&#160;<a class="el" href="group__vl53l1__ioctl.html#gga7eb4f9f10a8ea88d2af62881c8060860a38f60e5cf08f4c7b25124156be87cb0e">VL53L1_DISTANCEMODE_PAR</a> = 12, 
<a class="el" href="group__vl53l1__ioctl.html#gga7eb4f9f10a8ea88d2af62881c8060860a6b771923f7bbf4777cc58b77f3a01926">VL53L1_OUTPUTMODE_PAR</a> = 13, 
<a class="el" href="group__vl53l1__ioctl.html#gga7eb4f9f10a8ea88d2af62881c8060860a7f1c8a56a080d09a28fad476582da006">VL53L1_FORCEDEVICEONEN_PAR</a> = 14, 
<a class="el" href="group__vl53l1__ioctl.html#gga7eb4f9f10a8ea88d2af62881c8060860a8bf55a8a14267a78f805f2eb0cf6d8b6">VL53L1_LASTERROR_PAR</a> = 15, 
<br />
&#160;&#160;<a class="el" href="group__vl53l1__ioctl.html#gga7eb4f9f10a8ea88d2af62881c8060860a0387722db072f7db361f9256d707fa89">VL53L1_OFFSETCORRECTIONMODE_PAR</a> = 16, 
<a class="el" href="group__vl53l1__ioctl.html#gga7eb4f9f10a8ea88d2af62881c8060860a56d06cbbc3aa9cf51e4719d62f1031ae">VL53L1_OPTICALCENTER_PAR</a> = 17, 
<a class="el" href="group__vl53l1__ioctl.html#gga7eb4f9f10a8ea88d2af62881c8060860ae4d8dd1ac713ca4652a8831de1e41eb8">VL53L1_DMAXREFLECTANCE_PAR</a> = 18, 
<a class="el" href="group__vl53l1__ioctl.html#gga7eb4f9f10a8ea88d2af62881c8060860a5c7327d56004e41f92b1e728496e762b">VL53L1_DMAXMODE_PAR</a> = 19, 
<br />
&#160;&#160;<a class="el" href="group__vl53l1__ioctl.html#gga7eb4f9f10a8ea88d2af62881c8060860af583f8726e9d40fe53febd9a48b0f27a">VL53L1_TUNING_PAR</a> = 20, 
<a class="el" href="group__vl53l1__ioctl.html#gga7eb4f9f10a8ea88d2af62881c8060860a43fba66479fba72863aad320cceb3772">VL53L1_SMUDGECORRECTIONMODE_PAR</a> = 21, 
<a class="el" href="group__vl53l1__ioctl.html#gga7eb4f9f10a8ea88d2af62881c8060860ae33f1119d951022500faf4ad162ddee1">VL53L1_ISXTALKVALUECHANGED_PAR</a> = 22
<br />
 }</td></tr>
<tr class="separator:ga7eb4f9f10a8ea88d2af62881c8060860"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Ioctl commands for vl53L1. </p>
<p>ioctl are done across misc device <a class="el" href="group__vl53l1__ioctl.html#ga372d0423af5f910d7a572f2ffafb75fb">VL53L1_MISC_DEV_NAME</a> </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gae98e7032fc7af8d464e6f4ac8f6189ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define stmvl531_range_data_t&#160;&#160;&#160;VL53L1_RangingMeasurementData_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>register data use for simple/single ranging data <a class="el" href="group__vl53l1__ioctl.html#gae15aeca0d52d393e5e0af3d94dfba94f">VL53L1_IOCTL_GETDATAS</a></p>
<dl class="section warning"><dt>Warning</dt><dd>this definition is subject to change ! </dd></dl>

</div>
</div>
<a class="anchor" id="ga818e91493e897483de8fad8df755e7e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define stmvl531_zone_calibration_data_t&#160;&#160;&#160;struct _stmvl531_zone_calibration_data_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opaque structure use to hold content of zone offset calibration result. </p>

</div>
</div>
<a class="anchor" id="ga3fbcf2a7fb20d015d87b662dd74ae39a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VL53L1_CALIBRATION_CROSSTALK&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select crosstalk calibration in <a class="el" href="group__vl53l1__ioctl.html#ga57c964dd266d38f1525b43c92638586a">VL53L1_IOCTL_PERFORM_CALIBRATION</a>.</p>
<p>param1 is calibration method. param2 and param3 not use. </p><ul>
<li>VL53L1_XTALKCALIBRATIONMODE_NO_TARGET </li>
<li>VL53L1_XTALKCALIBRATIONMODE_SINGLE_TARGET </li>
<li>VL53L1_XTALKCALIBRATIONMODE_FULL_ROI </li>
</ul>

</div>
</div>
<a class="anchor" id="ga485f406fdc445a984cd120f532848647"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VL53L1_CALIBRATION_OFFSET&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select offset calibration <a class="el" href="group__vl53l1__ioctl.html#ga57c964dd266d38f1525b43c92638586a">VL53L1_IOCTL_PERFORM_CALIBRATION</a>. param1 is offset calibration mode. Parameter is either:</p><ul>
<li>VL53L1_OFFSETCALIBRATIONMODE_STANDARD</li>
<li>VL53L1_OFFSETCALIBRATIONMODE_PRERANGE_ONLY</li>
<li>VL53L1_OFFSETCALIBRATIONMODE_MULTI_ZONE (deprecated) param2 is target distance in mm. param3 is target reflectance in percent. Parameter is of type FixPoint1616_t.</li>
</ul>
<p>Note that VL53L1_OFFSETCALIBRATIONMODE_MULTI_ZONE usage is deprecated. Per zone offset calibration should use VL53L1_CALIBRATION_OFFSET_PER_ZONE instead. </p>

</div>
</div>
<a class="anchor" id="ga666b84222ce7345773d061a9fafab516"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VL53L1_CALIBRATION_OFFSET_PER_VCSEL&#160;&#160;&#160;5</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select per Vcsel offset calibration <a class="el" href="group__vl53l1__ioctl.html#ga57c964dd266d38f1525b43c92638586a">VL53L1_IOCTL_PERFORM_CALIBRATION</a>. param1 is target distance in mm. param2 and param3 are not used this calibration is used by the VL53L1_OFFSETCORRECTIONMODE_PERVCSEL mode </p>

</div>
</div>
<a class="anchor" id="gada26d146703c06fff5529587d57cb64b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VL53L1_CALIBRATION_OFFSET_PER_ZONE&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select offset calibration per zone <a class="el" href="group__vl53l1__ioctl.html#ga57c964dd266d38f1525b43c92638586a">VL53L1_IOCTL_PERFORM_CALIBRATION</a>. param1 is offset calibration mode. Parameter is:</p><ul>
<li>VL53L1_OFFSETCALIBRATIONMODE_MULTI_ZONE param2 is target distance in mm. param3 is target reflectance in percent. Parameter is of type FixPoint1616_t.</li>
</ul>
<p>Note that region of interest should be defined by a prior call to VL53L1_IOCTL_ROI before calling VL53L1_IOCTL_PERFORM_CALIBRATION / VL53L1_CALIBRATION_OFFSET combinaison. </p>

</div>
</div>
<a class="anchor" id="gac54e32ebe0f01d4199f0954ffd5a4045"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VL53L1_CALIBRATION_OFFSET_SIMPLE&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select simple offset calibration <a class="el" href="group__vl53l1__ioctl.html#ga57c964dd266d38f1525b43c92638586a">VL53L1_IOCTL_PERFORM_CALIBRATION</a>. param1 is target distance in mm. param2 and param3 are not used </p>

</div>
</div>
<a class="anchor" id="gaac13e726d19839b60a7471d41b1ff9f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VL53L1_CALIBRATION_OFFSET_ZERO_DISTANCE&#160;&#160;&#160;6</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select no Distance offset calibration <a class="el" href="group__vl53l1__ioctl.html#ga57c964dd266d38f1525b43c92638586a">VL53L1_IOCTL_PERFORM_CALIBRATION</a>. param1, param2 and param3 are not used </p>

</div>
</div>
<a class="anchor" id="gaa00d446b725ac0ddc98ad9269da67120"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VL53L1_CALIBRATION_REF_SPAD&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select reference spad calibration in <a class="el" href="group__vl53l1__ioctl.html#ga57c964dd266d38f1525b43c92638586a">VL53L1_IOCTL_PERFORM_CALIBRATION</a>.</p>
<p>param1, param2 and param3 not use </p>

</div>
</div>
<a class="anchor" id="gaeaf95795c4e59b6e197c452a541a6613"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VL53L1_IOCTL_AUTONOMOUS_CONFIG&#160;&#160;&#160;_IOWR('p', 0x14, struct stmvl53l1_autonomous_config_t)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set/get configure autonomous mode parameters</p>
<p>Allow to get or set autonomous configuration when device operates in VL53L1_PRESETMODE_AUTONOMOUS or VL53L1_PRESETMODE_LOWPOWER_AUTONOMOUS<br />
 Change it only when device is stopped otherwise you will receive an EBUSY error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structstmvl53l1__autonomous__config__t.html">stmvl53l1_autonomous_config_t</a></td><td>[in/out]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>autonomous config validity is only checked at start ranging , as such invalid autonomous config set can make start to fail.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success , see errno for error detail <ul>
<li>-EFAULT failed to copy from/to configuration. </li>
<li>-EBUSY when trying to change configuration while ranging. </li>
<li>-ENODEV. Device has been removed. example user land <br />
 trig interrupt when a target is withing [0..300mm[ distance <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;struct stmvl53l1_autonomous_config_t SD;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;SD.is_read = 0;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;SD.pollingTimeInMs = 100;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;SD.config.DetectionMode = 1;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;SD.config.Distance.CrossMode = 0;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;SD.config.Distance.Low = 300; </div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;rc = ioctl(fd, VL53L1_IOCTL_AUTONOMOUS_CONFIG, &amp;SD);</div>
</div><!-- fragment --> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga4905645a13244636db57baa5b46e479e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VL53L1_IOCTL_CALIBRATION_DATA&#160;&#160;&#160;_IOWR('p', 0x12, struct stmvl53l1_ioctl_calibration_data_t)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get / set calibration data</p>
<p>this call allow client to either read calibration data after calibration has been performed to store them in the host filesystem or push calibration data before ranging at each start-up.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">[in/out]</td><td>data struct ptr of type <a class="el" href="structstmvl53l1__ioctl__calibration__data__t.html">stmvl53l1_ioctl_calibration_data_t</a>. Caller should consider it as an opaque structure.</td></tr>
  </table>
  </dd>
</dl>
<p>use this after either VL53L1_CALIBRATION_REF_SPAD, VL53L1_CALIBRATION_CROSSTALK or VL53L1_CALIBRATION_OFFSET.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success else o, error check errno <ul>
<li>-EFAULT fault in cpy to f/m user out range data not copied </li>
<li>-EBUSY when trying to set calibration data while ranging </li>
<li>-EIO. Read last_error to get device error code </li>
<li>-ENODEV. Device has been removed. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gae15aeca0d52d393e5e0af3d94dfba94f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VL53L1_IOCTL_GETDATAS&#160;&#160;&#160;_IOWR('p', 0x0b, stmvl531_range_data_t)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>get single ranging data </p><dl class="section see"><dt>See also</dt><dd>for multi zone/objet</dd></dl>
<p>retrieve the last range data available form the device</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in/out</td><td>data struct ptr of type <a class="el" href="group__vl53l1__ioctl.html#gae98e7032fc7af8d464e6f4ac8f6189ac">stmvl531_range_data_t</a> it may come in but is out as of now</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success else o, error check errno <ul>
<li>-EFAULT fault in cpy to f/m user out range data not copied </li>
<li>-ENODEV. Device has been removed.</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>this ioctl will not wait for a new range sample acquisition it will return what available at time it get called . Hence same data maybe returned many time when doing fast polling.<br />
End user must inspect the data structure (time stamp etc )to find about it<br />
Despite it's non "waiting" nature this ioctl may still block/sleep shortly to ensure race free usage acquiring mutex and/or locks. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf7e64b1d59227b4b82bb8db88b268b4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VL53L1_IOCTL_GETDATAS_BLOCKING&#160;&#160;&#160;_IOWR('p', 0x10, stmvl531_range_data_t)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>get single ranging data </p><dl class="section see"><dt>See also</dt><dd>for multi zone/objet</dd></dl>
<p>this call is equivalent to VL53L1_IOCTL_GETDATAS but will block until new data are available since previous call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in/out</td><td>data struct ptr of type <a class="el" href="group__vl53l1__ioctl.html#gae98e7032fc7af8d464e6f4ac8f6189ac">stmvl531_range_data_t</a> it may come in but is out as of now</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success else o, error check errno <ul>
<li>-EFAULT fault in cpy to f/m user out range data not copied </li>
<li>-ENODEV device is not ranging or device has been removed. </li>
<li>-ERESTARTSYS interrupt while sleeping. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga98f10e3ab7049b6bb1afe72971e37397"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VL53L1_IOCTL_MZ_DATA&#160;&#160;&#160;_IOR('p', 0x0f, VL53L1_MultiRangingData_t)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get multi object/zone ranging data</p>
<p>this call is non blocking and will return what available internally in all case (veen error)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">multi</td><td>zone range VL53L1_MultiRangingData_t always update but -EFAULT error case</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success else o, error check errno <ul>
<li>-EFAULT fault in cpy to f/m user out range data not copyed </li>
<li>-ENOEXEC active mode is not mutli-zone </li>
<li>-ENODEV device is not ranging or device has been removed. as in that case MZ data may not be fully valid </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaae725507467c87b3446418d237565e05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VL53L1_IOCTL_MZ_DATA_BLOCKING&#160;&#160;&#160;_IOR('p', 0x11, VL53L1_MultiRangingData_t)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get multi object/zone ranging data</p>
<p>this call is equivalent to VL53L1_IOCTL_MZ_DATA but will block until new data are available since previous call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">multi</td><td>zone range VL53L1_MultiRangingData_t always update but -EFAULT error case</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success else o, error check errno <ul>
<li>-EFAULT fault in cpy to f/m user out range data not copyed </li>
<li>-ENOEXEC active mode is not mutli-zone </li>
<li>-ENODEV device is not ranging or device has been removed. </li>
<li>-ERESTARTSYS interrupt while sleeping. as in that case MZ data may not be fully valid </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga866f473341d9fb2c8cba7f430785df1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VL53L1_IOCTL_PARAMETER&#160;&#160;&#160;_IOWR('p', 0x0d, struct stmvl53l1_parameter)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set or get parameter</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameter</td><td>in/out <a class="el" href="structstmvl53l1__parameter.html">stmvl53l1_parameter</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>stmv53l1_parameter_name_e</dd></dl>
<p>for get if ioctl fail do not check for out params it is not valid for set theirs not copy back only see ioctl status, errno to get error case</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success else o, error check errno <ul>
<li>-ENODEV. Device has been removed.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>a set parameter may not be absorbed straight aways ! </dd></dl>

</div>
</div>
<a class="anchor" id="ga57c964dd266d38f1525b43c92638586a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VL53L1_IOCTL_PERFORM_CALIBRATION&#160;&#160;&#160;_IOW('p', 0x13, struct stmvl53l1_ioctl_perform_calibration_t)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>perform calibration squence according to calibration_type</p>
<p>this call is attended to be used during factory calibration. You select calibration to issue using calibration_type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>struct ptr of type <a class="el" href="structstmvl53l1__ioctl__perform__calibration__t.html">stmvl53l1_ioctl_perform_calibration_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success else o, error check errno <ul>
<li>-EFAULT fault in cpy to f/m user out range data not copied </li>
<li>-EBUSY when trying to perform calibration data while ranging </li>
<li>-EIO. Read last_error to get device error code </li>
<li>-ENODEV. Device has been removed. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gabc0270fe045a46443c981bcca1bf6c6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VL53L1_IOCTL_ROI&#160;&#160;&#160;_IOWR('p', 0x0e, struct stmvl53l1_roi_t)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set/get roi</p>
<p>shall only be use while device is stopped (EBUSY error otherwise) setting 0 rois stand for "disable  user define roi usage, use device default"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">roi_cfg</td><td>[in/out] type <a class="el" href="structstmvl53l1__roi__t.html">stmvl53l1_roi_t</a> and <a class="el" href="structstmvl53l1__roi__full__t.html">stmvl53l1_roi_full_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>when getting roi the returned roi cnt is set to available number of roi in driver but at most requested number or available one will be set in returned structure </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the coordinate system is not usual image x,y (y down)but traditional ecludian x,y (y up)</dd>
<dd>
once defined the user roi is kept alive until unset by user . User shall update roi when required (mode change etc ..)<br />
To return to default unset roi by setting none, device will return to default at next start</dd></dl>
<dl class="section note"><dt>Note</dt><dd>roi validity is only checked at start ranging , as such invalid roi set can make start to fail</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success , see errno for error detail <ul>
<li>EBUSY when trying to set roi while ranging </li>
<li>ENODEV never device get started and trying to get more rois than set </li>
<li>other errno code could be ll driver specific </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaf3e1756ac2d06f0c3ce0180f915bb19b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VL53L1_IOCTL_START&#160;&#160;&#160;_IO('p', 0x01)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start ranging (no argument)</p>
<dl class="section note"><dt>Note</dt><dd>sysfs and ioctl control are assumed mutual exclusive use control from ioctl execute with no consideration of sysfs path.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>: <ul>
<li>0 on success </li>
<li>-EBUSY if already started </li>
<li>-ENXIO failed to change i2c address change after reset release </li>
<li>-EIO. Read last_error to get device error code </li>
<li>-ENODEV. Device has been removed.</li>
</ul>
example user land : <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;int smtvl53l1_start(int fd){error</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;   int rc;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;   rc= ioctl(fd, VL53L1_IOCTL_START,NULL);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;   if( rc ){</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    if( errno == EBUSY){</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;        //the device is already started</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;        ioctl_warn(&quot;already started&quot;);</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;        return EBUSY;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    }</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;   }</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;   if( rc ){</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    ioctl_error(&quot;%d %s&quot;, rc,strerror(errno));</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;   }</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;   return rc;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;}</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5d8325482353615bad58ec14a7e61a10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VL53L1_IOCTL_STOP&#160;&#160;&#160;_IO('p', 0x05)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>stop ranging (no argument)</p>
<dl class="section note"><dt>Note</dt><dd>sysfs and ioctl control are assumed mutual exclusive use control from ioctl execute action with no consideration of sysfs path.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success </li>
<li>-EBUSY if it was already </li>
<li>-EIO. Read last_error to get device error code </li>
<li>-ENODEV. Device has been removed.</li>
</ul>
example user land : <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;int smtvl53l1_stop(int fd){</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;   int rc;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;   rc= ioctl(fd, VL53L1_IOCTL_STOP,NULL);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;   if( rc ){</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    if( errno == EBUSY ){</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;        ioctl_warn(&quot;already stopped&quot;);</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;        return errno;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    }</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    ioctl_error(&quot;%d %s&quot;, rc,strerror(errno));</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;   }</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;   return rc;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;}</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="gab8ccce5670a42edff7b3a66c6202d41a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VL53L1_IOCTL_ZONE_CALIBRATION_DATA&#160;&#160;&#160;_IOWR('p', 0x12, struct stmvl53l1_ioctl_zone_calibration_data_t)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get / set zone calibration data</p>
<p>this call allow client to either read zone calibration data after calibration has been performed to store them in the host filesystem or push zone calibration data before ranging at each start-up.</p>
<p>use this after VL53L1_CALIBRATION_OFFSET_PER_ZONE calibration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">[in/out]</td><td>data struct ptr of type <a class="el" href="structstmvl53l1__ioctl__zone__calibration__data__t.html">stmvl53l1_ioctl_zone_calibration_data_t</a>. Caller should consider it as an opaque structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success else o, error check errno <ul>
<li>-EFAULT fault in cpy to f/m user out range data not copied </li>
<li>-EBUSY when trying to set calibration data while ranging </li>
<li>-EIO. Read last_error to get device error code </li>
<li>-ENODEV. Device has been removed. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga372d0423af5f910d7a572f2ffafb75fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VL53L1_MISC_DEV_NAME&#160;&#160;&#160;&quot;stmvl53l1_ranging&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>misc device name for ioctl device</p>
<p>for mutli instance all device 2nd and next instance are basic name +"1"+"2" </p><ul>
<li>stmvl53l1_ranging </li>
<li>stmvl53l1_ranging1 </li>
<li>stmvl53l1_ranging2 </li>
</ul>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga7eb4f9f10a8ea88d2af62881c8060860"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__vl53l1__ioctl.html#ga7eb4f9f10a8ea88d2af62881c8060860">__stmv53l1_parameter_name_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>parameter name in <a class="el" href="structstmvl53l1__parameter.html">stmvl53l1_parameter</a> when using <a class="el" href="group__vl53l1__ioctl.html#ga866f473341d9fb2c8cba7f430785df1b">VL53L1_IOCTL_PARAMETER</a> </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga7eb4f9f10a8ea88d2af62881c8060860ac23cbef3e4624ab74dc78ec04af29557"></a>VL53L1_XTALKENABLE_PAR&#160;</td><td class="fielddoc">
<p>VL53L1_XTALKENABLE_PAR enable/disable crosstalk compensation<br />
valid value : </p><ul>
<li>0 disable crosstalk compensation </li>
<li>1 enable crosstalk compensation</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>mode can only be set while not ranging </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7eb4f9f10a8ea88d2af62881c8060860a712e39b760cbc9afaed8ec42d6cdc7c3"></a>VL53L1_DEVICEMODE_PAR&#160;</td><td class="fielddoc">
<p>DEVICEMODE_PAR set ranging mode  <br />
valid mode value : </p><ul>
<li>1 <em>VL53L1_PRESETMODE_RANGING</em> default ranging </li>
<li>2 <em>VL53L1_PRESETMODE_MULTIZONES_SCANNING</em> multiple zone </li>
<li>3 <em>VL53L1_PRESETMODE_AUTONOMOUS</em> autonomous mode </li>
<li>4 <em>VL53L1_PRESETMODE_LITE_RANGING</em> low mips ranging mode </li>
<li>8 <em>VL53L1_PRESETMODE_LOWPOWER_AUTONOMOUS</em> low power autonomous mode</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>VL53L1_PRESETMODE_LOWPOWER_AUTONOMOUS and VL53L1_PRESETMODE_AUTONOMOUS ranging modes use the polling time and the threholds set by <a class="el" href="group__vl53l1__ioctl.html#gaeaf95795c4e59b6e197c452a541a6613">VL53L1_IOCTL_AUTONOMOUS_CONFIG</a></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>mode can only be set while not ranging </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7eb4f9f10a8ea88d2af62881c8060860abc081c715c21fa932c4709b497881515"></a>VL53L1_POLLDELAY_PAR&#160;</td><td class="fielddoc">
<p>set the polling delay (msec)<br />
 </p><dl class="section note"><dt>Note</dt><dd>apply only when operates in polling mode as no effect otherwise </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7eb4f9f10a8ea88d2af62881c8060860a774e15d669bfb0ab611b1d74dacf69c4"></a>VL53L1_TIMINGBUDGET_PAR&#160;</td><td class="fielddoc">
<p>VL53L1_TIMINGBUDGET_PAR <a class="el" href="structstmvl53l1__parameter.html#a51312d39b8b78df21c32a8ecf016a942">stmvl53l1_parameter::value</a> field is timing budget in micro second</p>
<dl class="section note"><dt>Note</dt><dd>Please refer to VL53L1 user manual for minimum timing budget according to the selected mode</dd></dl>
<table class="doxtable">
<tr>
<th>Mode / timing budget </th><th>Min </th><th>Typical  </th></tr>
<tr>
<td>VL53L1_PRESETMODE_RANGING </td><td>8 ms </td><td>16 ms </td></tr>
<tr>
<td>VL53L1_PRESETMODE_MULTIZONES_SCANNING </td><td>8 ms </td><td>16 ms </td></tr>
<tr>
<td>VL53L1_PRESETMODE_AUTONOMOUS </td><td>41 ms </td><td>76 ms </td></tr>
<tr>
<td>VL53L1_PRESETMODE_LITE_RANGING </td><td>17 ms </td><td>66 ms </td></tr>
<tr>
<td>VL53L1_PRESETMODE_LOWPOWER_AUTONOMOUS </td><td>20 ms </td><td>20 ms </td></tr>
</table>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7eb4f9f10a8ea88d2af62881c8060860a38f60e5cf08f4c7b25124156be87cb0e"></a>VL53L1_DISTANCEMODE_PAR&#160;</td><td class="fielddoc">
<p>VL53L1_DISTANCEMODE_PAR valid distance mode value : </p><ul>
<li>1 <em>VL53L1_DISTANCEMODE_SHORT</em> </li>
<li>2 <em>VL53L1_DISTANCEMODE_MEDIUM</em> </li>
<li>3 <em>VL53L1_DISTANCEMODE_LONG</em> </li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>distance mode can only be set while not ranging </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7eb4f9f10a8ea88d2af62881c8060860a6b771923f7bbf4777cc58b77f3a01926"></a>VL53L1_OUTPUTMODE_PAR&#160;</td><td class="fielddoc">
<p>VL53L1_OUTPUTMODE_PAR valid output mode value : </p><ul>
<li>1 <em>VL53L1_OUTPUTMODE_NEAREST</em> </li>
<li>2 <em>VL53L1_OUTPUTMODE_STRONGEST</em> </li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>distance mode can only be set while not ranging </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7eb4f9f10a8ea88d2af62881c8060860a7f1c8a56a080d09a28fad476582da006"></a>VL53L1_FORCEDEVICEONEN_PAR&#160;</td><td class="fielddoc">
<p>VL53L1_FORCEDEVICEONEN_PAR This parameter will control if device is put under reset when stopped. valid force device on value : </p><ul>
<li>0 feature is disable. Device is put under reset when stopped. </li>
<li>1 feature is enable. Device is not put under reset when stopped. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7eb4f9f10a8ea88d2af62881c8060860a8bf55a8a14267a78f805f2eb0cf6d8b6"></a>VL53L1_LASTERROR_PAR&#160;</td><td class="fielddoc">
<p>VL53L1_LASTERROR_PAR This is a read only parameter. It will return last device internal error. It's valid only after an ioctl/sysfs return an -EIO error. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7eb4f9f10a8ea88d2af62881c8060860a0387722db072f7db361f9256d707fa89"></a>VL53L1_OFFSETCORRECTIONMODE_PAR&#160;</td><td class="fielddoc">
<p>VL53L1_OFFSETCORRECTIONMODE_PAR This parameter will define which mode to use for the offset correction. valid force device on value : </p><ul>
<li>1 <em>VL53L1_OFFSETCORRECTIONMODE_STANDARD</em> </li>
<li>2 <em>VL53L1_OFFSETCORRECTIONMODE_PERZONE</em> </li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>offset correction mode can only be set while not ranging </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7eb4f9f10a8ea88d2af62881c8060860a56d06cbbc3aa9cf51e4719d62f1031ae"></a>VL53L1_OPTICALCENTER_PAR&#160;</td><td class="fielddoc">
<p>VL53L1_OPTICALCENTER_PAR This is a read only parameter. It will return optical center issued from the nvm set at FTM stage. value will contain X position of center. value2 will contain Y position of center. Return values have FixPoint1616_t type. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7eb4f9f10a8ea88d2af62881c8060860ae4d8dd1ac713ca4652a8831de1e41eb8"></a>VL53L1_DMAXREFLECTANCE_PAR&#160;</td><td class="fielddoc">
<p>VL53L1_DMAXREFLECTANCE_PAR This parameter will define target reflectance @ 940nm used to calculate the ambient DMAX. Parameter is of type FixPoint1616_t.</p>
<dl class="section warning"><dt>Warning</dt><dd>dmax reflectance can only be be set while not ranging </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7eb4f9f10a8ea88d2af62881c8060860a5c7327d56004e41f92b1e728496e762b"></a>VL53L1_DMAXMODE_PAR&#160;</td><td class="fielddoc">
<p>VL53L1_DMAXMODE_PAR This parameter will select Dmax mode. valid Dmax mode value : </p><ul>
<li>1 <em>VL53L1_DMAXMODE_FMT_CAL_DATA</em> </li>
<li>2 <em>VL53L1_DMAXMODE_CUSTCAL_DATA</em> </li>
<li>3 <em>VL53L1_DMAXMODE_PER_ZONE_CAL_DATA</em> </li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>Dmax mode can only be set while not ranging </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7eb4f9f10a8ea88d2af62881c8060860af583f8726e9d40fe53febd9a48b0f27a"></a>VL53L1_TUNING_PAR&#160;</td><td class="fielddoc">
<p>VL53L1_DMAXMODE_PAR This parameter is a write only parameter. It will allow to provide low level layer with a configuration parameter. value will be use as a key parameter. value2 will be use as value parameter.</p>
<dl class="section warning"><dt>Warning</dt><dd>those configuration parameter settings are only allowed before device is start once. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7eb4f9f10a8ea88d2af62881c8060860a43fba66479fba72863aad320cceb3772"></a>VL53L1_SMUDGECORRECTIONMODE_PAR&#160;</td><td class="fielddoc">
<p>VL53L1_SMUDGECORRECTIONMODE_PAR This parameter will control if smudge correction is enable and how crosstalk values are updated. </p><ul>
<li>0 <em>VL53L1_SMUDGE_CORRECTION_NONE</em> </li>
<li>1 <em>VL53L1_SMUDGE_CORRECTION_CONTINUOUS</em> </li>
<li>2 <em>VL53L1_SMUDGE_CORRECTION_SINGLE</em> </li>
<li>3 <em>VL53L1_SMUDGE_CORRECTION_DEBUG</em> </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7eb4f9f10a8ea88d2af62881c8060860ae33f1119d951022500faf4ad162ddee1"></a>VL53L1_ISXTALKVALUECHANGED_PAR&#160;</td><td class="fielddoc">
<p>VL53L1_ISXTALKCHANGED_PAR This is a read only parameter. It will return if Xtalk value has been updated while ranging. This parameter is reset each time device start to range. </p><ul>
<li>0 Xtalk values has not been changed. </li>
<li>1 Xtalk values has been changed. </li>
</ul>
</td></tr>
</table>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Nov 22 2021 14:31:13 for VL53L1linuxdriver by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
